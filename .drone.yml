---
global-variables:
  testrunner-image: &testrunner-image quay.io/ukhomeofficedigital/tf-testrunner:32
  # testrunner-image: &testrunner-image quay.io/ukhomeofficedigital/tf-testrunner:TF1.6
  terragrunt-image: &terragrunt-image quay.io/ukhomeofficedigital/dq-docker-terragrunt:v0.23.18
#  terragrunt-image: &terragrunt-image quay.io/ukhomeofficedigital/dq-docker-terragrunt:v0.26.2 # TF0.13
  # terragrunt-image: &terragrunt-image quay.io/ukhomeofficedigital/dq-docker-terragrunt:TGv0.54.4_TFv1.6.6
  vault-image: &vault-image docker.digital.homeoffice.gov.uk/dq/dq-vault-awscli:1.43

kind: pipeline
name: default
type: kubernetes

platform:
  os: linux
  arch: amd64

environment:
  BUCKET: terraform-statefiles-all-envs
  STATE_FILE: consolidated-schedule
  TF_VERSION: 1.6
  AWS_REGION: eu-west-2
  DEPLOYMENT_TYPE: dq-tf-infra

x-anchors:
  retrieve-state-aws-key: &retrieve-state-aws-key
    - vault --version
    - export AWS_ENV="state"
    # All Terraform State is held in an S3 Bucket in the 'test' AWS Account
    # - so all Terraform steps will need to source AWS_SECRETS_FILE
    - export AWS_CREDS_FILE="aws_creds_$${AWS_ENV}.json"
    - export AWS_SECRETS_FILE="set_aws_secrets_$${AWS_ENV}.sh"
    # Retrieve vault secrets
    - vault read aws_dacc_dq/creds/drone > $${AWS_CREDS_FILE}
    - export LEASE_ID=$(cat $${AWS_CREDS_FILE} | grep lease_id | awk -F ' ' '{print $2}')
    - export ACCESS_KEY=$(cat $${AWS_CREDS_FILE} | grep access_key | awk -F ' ' '{print $2}')
    - export SECRET_KEY=$(cat $${AWS_CREDS_FILE} | grep secret_key | awk -F ' ' '{print $2}')
    # Update the token TTL to 10mins
    - vault lease renew -increment=3600 $${LEASE_ID}
    # Get the AWS credentials - for `Terragrunt/Terraform`
    - echo "export AWS_ACCESS_KEY_ID=$${ACCESS_KEY}" > $${AWS_SECRETS_FILE}
    - echo "export AWS_SECRET_ACCESS_KEY=$${SECRET_KEY}" >> $${AWS_SECRETS_FILE}
    - echo "export AWS_DEFAULT_REGION=$${AWS_REGION}" >> $${AWS_SECRETS_FILE}

  retrieve-deployment-aws-key: &retrieve-deployment-aws-key
    - vault --version
    # Set AWS Account from step's environment variable AWS_ENV
    - export AWS_CREDS_FILE="aws_creds_$${AWS_ENV}.json"
    - export AWS_SECRETS_FILE="set_aws_secrets_$${AWS_ENV}.sh"
    # Retrieve vault secrets
    - vault read aws_dacc_dq/creds/drone > $${AWS_CREDS_FILE}
    - export LEASE_ID=$(cat $${AWS_CREDS_FILE} | grep lease_id | awk -F ' ' '{print $2}')
    - export ACCESS_KEY=$(cat $${AWS_CREDS_FILE} | grep access_key | awk -F ' ' '{print $2}')
    - export SECRET_KEY=$(cat $${AWS_CREDS_FILE} | grep secret_key | awk -F ' ' '{print $2}')
    # Update the token TTL to 10mins
    - vault lease renew -increment=3600 $${LEASE_ID}
    # Get the AWS credentials - to allow Terraform to deploy to the Target Account
    - echo "export TF_VAR_ENV_ACCT_ID=$${ACCESS_KEY}" > $${AWS_SECRETS_FILE}
    - echo "export TF_VAR_ENV_ACCT_KEY=$${SECRET_KEY}" >> $${AWS_SECRETS_FILE}
    - echo "export AWS_DEFAULT_REGION=$${AWS_REGION}" >> $${AWS_SECRETS_FILE}

  check-format: &check-format
    - terraform --version
    - terraform fmt --diff --check

  run-testrunner-tests: &run-testrunner-tests
    # Get AWS secrets for TF State
    - export AWS_SECRETS_FILE="/drone/src/set_aws_secrets_$${AWS_ENV}.sh"
    - source $${AWS_SECRETS_FILE}
    # Run the actual tests
    - python -m unittest tests/*_test.py

  tf-init: &tf-init
    # Get AWS secrets for TF State
    - export AWS_SECRETS_FILE="set_aws_secrets_state.sh"
    - source $${AWS_SECRETS_FILE}
    # Get AWS secrets for Target Account
    - export AWS_SECRETS_FILE="set_aws_secrets_$${AWS_ENV}.sh"
    - source $${AWS_SECRETS_FILE}
    # Create config files for Terragrunt
    - echo -e "provider \"aws\" {\n  region = \"$AWS_DEFAULT_REGION\"\n}" > provider.tf
    - echo -e "terraform {\n  backend \"s3\" {}\n}" > backend.tf
    - echo -e "remote_state {\n  backend = \"s3\"\n  config = {\n  bucket = \"$BUCKET\"\n  region = \"$AWS_DEFAULT_REGION\"\n  dynamodb_table = \"terraform-state\"\n  key = \"$DEPLOYMENT_TYPE/terraform-$TF_VERSION/$AWS_ENV/$STATE_FILE.tfstate\"\n  encrypt = true \n  }\n}" > terragrunt.hcl
    # INIT
    - terraform --version
    - terragrunt --version
    - terragrunt init -reconfigure

  tf-validate: &tf-validate
    # Get AWS secrets for TF State
    - export AWS_SECRETS_FILE="set_aws_secrets_state.sh"
    - source $${AWS_SECRETS_FILE}
    # Get AWS secrets for Target Account
    - export AWS_SECRETS_FILE="set_aws_secrets_$${AWS_ENV}.sh"
    - source $${AWS_SECRETS_FILE}
    # VALIDATE
    - terraform --version
    - terragrunt --version
    - terragrunt validate

  tf-plan: &tf-plan
    # Get AWS secrets for TF State
    - export AWS_SECRETS_FILE="set_aws_secrets_state.sh"
    - source $${AWS_SECRETS_FILE}
    # Get AWS secrets for Target Account
    - export AWS_SECRETS_FILE="set_aws_secrets_$${AWS_ENV}.sh"
    - source $${AWS_SECRETS_FILE}
    # PLAN
    - terraform --version
    - terragrunt --version
    - terragrunt plan -lock=false -out=plan_$${AWS_ENV}

  tf-apply: &tf-apply
    # Get AWS secrets for TF State
    - export AWS_SECRETS_FILE="set_aws_secrets_state.sh"
    - source $${AWS_SECRETS_FILE}
    # Get AWS secrets for Target Account
    - export AWS_SECRETS_FILE="set_aws_secrets_$${AWS_ENV}.sh"
    - source $${AWS_SECRETS_FILE}
    # APPLY
    - terraform --version
    - terragrunt --version
    - terragrunt apply -auto-approve -parallelism=50 plan_$${AWS_ENV}


steps:
  # Used to access TF state-file
- name: retrieve-aws-secrets-tf-state
  pull: always
  image: *vault-image
  commands: *retrieve-state-aws-key
  environment:
    VAULT_ADDR:
      from_secret: VAULT_ADDR_DEV
    VAULT_TOKEN:
      from_secret: VAULT_TOKEN_DEV
  when:
    event:
      - push

- name: check-format
  pull: if-not-exists
  image: *terragrunt-image
  commands: *check-format
  when:
    event:
      - push

- name: run-testrunner-tests
  pull: if-not-exists
  image: *testrunner-image
  commands: *run-testrunner-tests
  environment:
    AWS_ENV: state
  when:
    event:
      - push

  # AWS 'Test' account Secrets - used to deploy to 'Test' account
- name: retrieve-aws-secrets-test
  pull: always
  image: *vault-image
  commands: *retrieve-deployment-aws-key
  environment:
    AWS_ENV: test
    VAULT_ADDR:
      from_secret: VAULT_ADDR_DEV
    VAULT_TOKEN:
      from_secret: VAULT_TOKEN_DEV
  when: # Init & Plan when feature branch pushed
    event:
      - push

- name: init-test
  pull: always
  image: *terragrunt-image
  commands: *tf-init
  environment:
    AWS_ENV: test
  when: # Init & Plan when feature branch pushed
    event:
      - push

- name: validate-test
  pull: if-not-exists
  image: *terragrunt-image
  commands: *tf-validate
  environment:
    AWS_ENV: test
  when: # Init & Plan when feature branch pushed
    event:
      - push

- name: plan-test
  pull: if-not-exists
  image: *terragrunt-image
  commands: *tf-plan
  environment:
    AWS_ENV: test
  when: # Init & Plan when feature branch pushed
    event:
      - push

- name: apply-test
  pull: if-not-exists
  image: *terragrunt-image
  commands: *tf-apply
  environment:
    AWS_ENV: test
  when: # Apply when feature branch merged
    event:
      - push
    branch:
      include:
        - master
